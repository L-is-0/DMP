# DO NOT EDIT THIS FILE
from multiprocessing import Manager, Process
from flask import Flask, request, jsonify
import json
from time import clock
import os
from q1 import findbestprofit
from q2 import findDiversifiedPortfolio
from q3 import findSafeNetwork

app = Flask(__name__)


# IMPORTANT: DO NOT CHANGE THIS FUNCTION
@app.route('/runq1', methods=['POST'])
def runq1_main():
    q1inputs = json.loads(request.data)[0]

    response = []
    for q1input in q1inputs:
        try:
            return_dict = Manager().dict()
            p = Process(target=runq1, args=(q1input, return_dict))
            p.start()

            # Wait for 3 seconds or until process finishes
            p.join(3)

            # If thread is still active
            if p.is_alive():
                # Terminate
                print("A question 1 test has timed out. Each individual test has a maximum of three seconds to run.")
                p.terminate()
                p.join()
                response.append((-1, -1))
            else:
                response.append((return_dict['output'], return_dict['diff']))
        except:
            response.append((-1, -1))

    response = jsonify(response)
    response.headers.add('Access-Control-Allow-Origin', '*')
    return response


# DO NOT CHANGE THIS FUNCTION EITHER
def runq1(q1input, return_dict):
    start = clock()
    output = findbestprofit(q1input[0], q1input[1])
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff


# IMPORTANT: DO NOT CHANGE THIS FUNCTION
@app.route('/runq2', methods=['POST'])
def runq2_main():
    q2inputs = json.loads(request.data)[1]

    response = []
    for q2input in q2inputs:
        try:
            return_dict = Manager().dict()
            p = Process(target=runq2, args=(q2input, return_dict))
            p.start()

            # Wait for 10 seconds or until process finishes
            p.join(3)

            # If thread is still active
            if p.is_alive():
                # Terminate
                print("A question 2 test has timed out. Each individual test has a maximum of three seconds to run.")
                p.terminate()
                p.join()
                response.append((-1, -1))
            else:
                response.append((return_dict['output'], return_dict['diff']))
        except:
            response.append((-1, -1))

    response = jsonify(response)
    response.headers.add('Access-Control-Allow-Origin', '*')
    return response


# DO NOT CHANGE THIS FUNCTION EITHER
def runq2(q2input, return_dict):
    start = clock()
    output = findDiversifiedPortfolio(q2input[0], q2input[1])
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff


# IMPORTANT: DO NOT CHANGE THIS FUNCTION
@app.route('/runq3', methods=['POST'])
def runq3_main():
    q3inputs = json.loads(request.data)[2]

    response = []
    for q3input in q3inputs:
        try:
            return_dict = Manager().dict()
            p = Process(target=runq3, args=(q3input, return_dict))
            p.start()

            # Wait for 10 seconds or until process finishes
            p.join(3)

            # If thread is still active
            if p.is_alive():
                # Terminate
                print("A question 3 test has timed out. Each individual test has a maximum of three seconds to run.")
                p.terminate()
                p.join()
                response.append((-1, -1))
            else:
                response.append((return_dict['output'], return_dict['diff']))
        except:
            response.append((-1, -1))

    response = jsonify(response)
    response.headers.add('Access-Control-Allow-Origin', '*')
    return response


# DO NOT CHANGE THIS FUNCTION EITHER
def runq3(q3input, return_dict):
    start = clock()
    output = findSafeNetwork(q3input[0], q3input[1], q3input[2])
    end = clock()
    diff = end - start
    return_dict['output'] = output
    return_dict['diff'] = diff


if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8182))
    app.run(host='0.0.0.0', port=port)
